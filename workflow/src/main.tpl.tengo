wf := import("@platforma-sdk/workflow-tengo:workflow")
assets:= import("@platforma-sdk/workflow-tengo:assets")
render := import("@platforma-sdk/workflow-tengo:render")
xsv := import("@platforma-sdk/workflow-tengo:pframes.xsv")
pframes := import("@platforma-sdk/workflow-tengo:pframes")
pSpec := import("@platforma-sdk/workflow-tengo:pframes.spec")
json := import("json")

pfPseudotimeConv := import(":pf-pseudotime-conv")
pfPagaGraphConv := import(":pf-paga-graph-conv")
pfUmapDensityConv := import(":pf-umap-density-conv")
pseudotimeInferenceTpl := assets.importTemplate(":pseudotime-inference-calculation")

wf.prepare(func(args){
	// Validate cluster annotation is provided
	if is_undefined(args.clusterAnnotationRef) {
		error("Cluster annotation is required")
	}

	// Create bundle builder for automatic PColumn discovery
	bundleBuilder := wf.createPBundleBuilder()
	bundleBuilder.ignoreMissingDomains() // Handle various data types
	
	// Add the cluster annotation as the main anchor
	bundleBuilder.addAnchor("clusters", args.clusterAnnotationRef)
	
	// Add query for count matrix - we'll filter this in body based on trace analysis
	bundleBuilder.addMulti({
		name: "pl7.app/rna-seq/pcvalue"
	}, "principalComponents")

	// Add query for UMAP
	bundleBuilder.addMulti({
		name: "pl7.app/rna-seq/umap1"
	}, "umap1")
	bundleBuilder.addMulti({
		name: "pl7.app/rna-seq/umap2"
	}, "umap2")
	
	return {
		columns: bundleBuilder.build()
	}
})

wf.body(func(args) {
	// Extract block ID as string
	blockId := wf.blockId().getDataAsJson()
	
	// Get the resolved cluster annotation
	columns := args.columns
	clusterAnnotation := columns.getColumn(args.clusterAnnotationRef)
	clusterSpec := clusterAnnotation.spec
	
	if is_undefined(clusterSpec.annotations) {
		error("Cluster annotation is missing required metadata.")
	}
	
	clusterTraceAnnotation := clusterSpec.annotations["pl7.app/trace"]
	if is_undefined(clusterTraceAnnotation) {
		error("Cluster annotation is missing trace information.")
	}
	
	clusterTrace := json.decode(clusterTraceAnnotation || "[]")
	
	// Extract PCA block ID from trace
	pcaBlockId := undefined
	for step in clusterTrace {
		if !is_undefined(step) && !is_undefined(step.type) && (step.type == "milaboratories.pca" || step.type == "milaboratories.harmony-pca" || step.type == "milaboratories.dimensionality-reduction") {
			if !is_undefined(step.id) {
				pcaBlockId = step.id
				break
			}
		}
	}
	
	if pcaBlockId == undefined {
		error("Could not find PCA step in cluster annotation trace.")
	}
	
	// Find the matching principal components from the available ones
	allPrincipalComponents := columns.getColumns("principalComponents")
	principalComponents := undefined
	
	for pc in allPrincipalComponents {
		if !is_undefined(pc.spec.domain) && 
		   pc.spec.domain["pl7.app/blockId"] == pcaBlockId {
			principalComponents = pc
			break
		}
	}
	
	if is_undefined(principalComponents) {
		error("No associated principal components found for the given cluster annotation.")
	}

	// Find the matching UMAP coordinates from the available ones
	allUMAPCoordinates1 := columns.getColumns("umap1")
	umapCoordinates1 := undefined
	allUMAPCoordinates2 := columns.getColumns("umap2")
	umapCoordinates2 := undefined

	// First check if we have batch corrected results
	batchCorrected := "false"
	for pc in allUMAPCoordinates1 {
		if !is_undefined(pc.spec.domain) && 
		   pc.spec.domain["pl7.app/blockId"] == pcaBlockId &&
		   pc.spec.domain["pl7.app/rna-seq/batch-corrected"] == "true" {
			batchCorrected = "true"
			break
		}
	}
	
	for pc in allUMAPCoordinates1 {
		if !is_undefined(pc.spec.domain) && 
		   pc.spec.domain["pl7.app/blockId"] == pcaBlockId &&
		   pc.spec.domain["pl7.app/rna-seq/batch-corrected"] == batchCorrected {
			umapCoordinates1 = pc
			break
		}
	}
	for pc in allUMAPCoordinates2 {
		if !is_undefined(pc.spec.domain) && 
		   pc.spec.domain["pl7.app/blockId"] == pcaBlockId &&
		   pc.spec.domain["pl7.app/rna-seq/batch-corrected"] == batchCorrected {
			umapCoordinates2 = pc
			break
		}
	}
	
	if is_undefined(umapCoordinates1) || is_undefined(umapCoordinates2) {
		error("No associated UMAP coordinates found for the given cluster annotation.")
	}

	inputSpec := principalComponents.spec

	// Set default conversion memory and CPU
	defaultConvMem := "16GiB" // @TODO: set based on the size of the input
	defaultConvCpu := 1       // @TODO: set based on the size of the input

	csvEmbeddings := xsv.exportFrame([principalComponents], "csv", { mem: defaultConvMem, cpu: defaultConvCpu })
	csvClusters := xsv.exportFrame([clusterAnnotation], "csv", { mem: defaultConvMem, cpu: defaultConvCpu })
	csvUmapCoordinates := xsv.exportFrame([umapCoordinates1, umapCoordinates2], "csv", { mem: defaultConvMem, cpu: defaultConvCpu })

	pseudotimeInferenceRender := render.create(pseudotimeInferenceTpl, {
		csvEmbeddings: csvEmbeddings,
		csvClusters: csvClusters,
		csvUmapCoordinates: csvUmapCoordinates,
		rootCluster: args.rootCluster,
		mem: "16GiB",
		cpu: 1
	})

	pseudotimeScoresImportParams := pfPseudotimeConv.getColumns(blockId, inputSpec)
	pseudotimePf := xsv.importFile(pseudotimeInferenceRender.output("pseudotimeCsv"), "csv", pseudotimeScoresImportParams, {splitDataAndSpec: true, mem: defaultConvMem, cpu: defaultConvCpu})
	pagaGraphImportParams := pfPagaGraphConv.getColumns(blockId, inputSpec)
	pagaGraphPf := xsv.importFile(pseudotimeInferenceRender.output("pagaGraphCsv"), "csv", pagaGraphImportParams, {mem: defaultConvMem, cpu: defaultConvCpu})
	umapDensityImportParams := pfUmapDensityConv.getColumns(blockId, inputSpec)
	umapDensityPf := xsv.importFile(pseudotimeInferenceRender.output("umapDensityCsv"), "csv", umapDensityImportParams, {mem: defaultConvMem, cpu: defaultConvCpu})
	
	// Create informative label with cluster annotation and root cluster parameter if provided
	clusterLabel := clusterSpec.annotations["pl7.app/label"]
	traceLabel := "Pseudotime Inference (" + clusterLabel + ")"
	if !is_undefined(args.rootCluster) {
		rootClusterStr := string(args.rootCluster)
		traceLabel = "Pseudotime Inference (" + clusterLabel + ", root:" + rootClusterStr + ")"
	}
	
	trace := pSpec.makeTrace(inputSpec,
		{type: "milaboratories.pseudotime-inference", id: blockId, importance: 60, label: traceLabel}
	)

	// Build pseudotime scores pFrame with trace injection
	pseudotimeOutputPf := pframes.pFrameBuilder()
	for k, v in pseudotimePf {
		pseudotimeOutputPf.add(k, trace.inject(v.spec), v.data)
	}
	pseudotimeOutputPf = pseudotimeOutputPf.build()

	return {
		outputs: {
			pseudotimeScores: pframes.exportFrame(pseudotimeOutputPf),
			pagaGraph: pframes.exportFrame(pagaGraphPf),
			umapDensity: pframes.exportFrame(umapDensityPf)
		},
		exports: {
			pf: pseudotimeOutputPf
		}
	}
})

